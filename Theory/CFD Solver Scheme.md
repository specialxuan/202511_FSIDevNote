# CFD Solver Scheme

## 投影法（分裂步法）

投影法，通常也称为**分裂步法**，是求解不可压缩 Navier-Stokes 方程的一类核心算法。其基本思想是将速度场的更新与压力场的求解分离开，通过一个"投影"步骤来保证最终获得的速度场满足连续性方程。

### 核心思想

该方法的核心哲学在于将时间步进过程分裂为两个子步骤：

- **预测步**：在不考虑压力梯度（或使用旧的压力场）的情况下，通过对流和扩散效应初步更新速度场，得到一个**中间速度场 $\mathbf{v}^*$**。该速度场通常是有散度的，即 $\nabla \cdot \mathbf{v}^* \neq 0$，不满足质量守恒

- **投影步**：这是方法的精髓。将中间速度场 $\mathbf{v}^*$ 投影到满足连续性方程的散度为零的空间上，从而得到物理上正确的、无散的速度场 $\mathbf{v}^{n+1}$。这个投影操作通过求解一个来源于压力场的泊松方程来实现

正如文件第 214 页所精辟论述的：

> "...the pressure acts through the continuity restraint as an operator which projects the divergent velocity vector field into a non-divergent vector field..."
> （...压力通过连续性约束作为一个算子，将发散的矢量速度场投影到一个无散的矢量场中...）

这清晰地表明，在数学上，**压力的物理作用在算法中被体现为一个投影算子**，其功能是修正速度场，使其满足 $\nabla \cdot \mathbf{v} = 0$。

### 算法流程（以基础版本为例）

**速度预测**：求解一个忽略或部分处理压力项的动量方程

$$\frac{\mathbf{v}^* - \mathbf{v}^n}{\Delta t} = - (\mathbf{v}^n \cdot \nabla) \mathbf{v}^n + \nu \nabla^2 \mathbf{v}^n$$

**压力泊松方程**：将动量方程与连续性方程结合，推导出一个关于压力 $p$ 或压力修正 $p'$ 的泊松方程

$$\nabla^2 p^{n+1} = \frac{\rho}{\Delta t} \nabla \cdot \mathbf{v}^*$$

**速度修正**：利用求得的压力场来修正预测速度，使其变得无散

$$\frac{\mathbf{v}^{n+1} - \mathbf{v}^*}{\Delta t} = -\frac{1}{\rho} \nabla p^{n+1}$$

### 主要变体

根据在预测步中如何处理压力，分裂步法有以下常见变体：

- **P1 方法**：预测步中完全忽略压力项 ($p = 0$)
- **P2 方法**：预测步中使用前一个时间步的压力 ($p = p^n$)，然后在投影步中求解压力修正 $p'$
- **P3 方法**：使用更高阶的外推法（如利用 $p^n$ 和 $p^{n-1}$）来估计新时间步的压力，用于预测步

### 与 SIMPLE 类方法的联系

SIMPLE、SIMPLEC 和 PISO 等算法在广义上也属于投影法的范畴。它们同样遵循"预测-修正"的范式，在每一个（外层）迭代步中，都执行了一个将速度场向无散空间投影的操作。关键区别在于，这些方法在离散化的层面上进行操作，并且在处理耦合与非线性的策略上（尤其是在稳态问题中）更为复杂。

## SIMPLE 算法

SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）算法是一种用于求解不可压缩 Navier-Stokes 方程的压力-速度耦合的迭代方法，主要用于稳态流动计算，也可用于瞬态问题。

### 1.算法初始化

在第$n$时间步，使用上一时间步或初始猜测值 $u_i^n$、$p^n$ 作为当前迭代的初始估计 $u_i^{n+1}$、$p^{n+1}$。

### 2.动量方程预测

在第$m$迭代步，使用上一迭代步的压力 $p^{m-1}$ 求解线性化后的动量方程，得到预测速度 $u_i^*$：

$$A^{m-1} u_i^* = Q_i^{m-1} - G_i(p^{m-1})$$

其中：

- $A$ 是系数矩阵（包含对流、扩散、非稳态项）
- $Q$ 是源项（包含显式处理的项、体力、非稳态项中已知部分等）
- $G_i$ 是压力梯度算子

### 3.压力修正

压力修正方程来源于连续性方程，形式为：

$$D\left( \rho (A_D)^{-1} G(p') \right) = D(\rho u_i^*)$$

其中：

- $D$ 是散度算子
- $A_D$ 是动量方程中对角线系数矩阵

修正压力 $p^m$：

$$p^m = p^{m-1} + \alpha_p p'$$

其中 $\alpha_p$ 是压力修正的松弛因子（$\alpha_p < 1$）。

### 4.速度修正

使用压力修正 $p'$ 修正速度：

$$u_i^{**} = u_i^* - (A_D)^{-1} G_i(p')$$

修正后的速度 $u_i^{**}$ 满足连续性方程（在离散意义上）。

### 5.其他输运方程求解

如能量、湍流、组分等方程，使用更新后的速度和压力。

### 6.物性更新

如为变物性流动，使用当前迭代的变量值更新流体物性（如密度、粘度等）。

### 7.收敛性检查

若未收敛，返回外层迭代循环继续迭代；若收敛，则进入下一时间步或结束计算。

### SIMPLE 算法特点

- **忽略非对角项影响（SIMPLE 算法的关键）**：在推导速度修正关系时，忽略了非对角项的影响，这是 SIMPLE 算法的主要简化，也是其收敛较慢的原因
- **压力修正的松弛**：为防止发散，压力修正通常需要松弛（$\alpha_p \approx 0.1 \sim 0.3$）
- **适用于稳态和瞬态**：通过引入非稳态项，也可用于瞬态问题
- **适用于不可压缩流动**：为不可压缩 Navier-Stokes 方程设计
- **可扩展性强**：易于耦合其他输运方程（如能量、湍流等）
- **计算效率**：相较于其他压力-速度耦合方法（如 PISO），SIMPLE 算法计算效率较低，但实现简单，适用于多种流动问题

## IFSM 算法

IFSM（Iterative Fractional-Step Method，迭代分裂步方法）是一种用于求解不可压缩 Navier-Stokes 方程的隐式时间推进方法，结合了分裂步法的思想与迭代求解策略，适用于瞬态流动的高精度计算。

### 1. 算法初始化

在第$n$时间步，使用上一时间步的收敛解 $u_i^n$、$p^{n-1/2}$ 作为当前时间步的初始估计值 $u_i^{n+1}$、$p^{n+1/2}$。

### 2. 速度预测步

在第$m$迭代步，使用前一时间步的压力 $p^{n-1/2}$ 求解隐式动量方程，得到预测速度 $v^*$：

$$\frac{(\rho v)^* - (\rho v)^n}{\Delta t} + C(v^{n+1/2}) = -G(p^{n-1/2}) + \frac{L(v^*) + L(v^n)}{2}$$

其中：

- $C(v)$ 为对流项算子，采用 Adams-Bashforth 格式离散：$C(v^{n+1/2}) \approx \frac{3}{2}C(v^n) - \frac{1}{2}C(v^{n-1})$
- $G$ 为压力梯度算子
- $L(v)$ 为粘性项算子，采用 Crank-Nicolson 格式离散

### 3. 压力修正计算

定义压力修正 $p'$ 并建立压力泊松方程：

$$p^{n+1/2} = p^{n-1/2} + p'$$

$$D(G(p')) = \frac{D(\rho v)^*}{\Delta t}$$

其中 $D$ 为散度算子。

### 4. 速度和压力更新

利用压力修正量更新速度和压力场：

$$(\rho v)^{n+1} = (\rho v)^* - \Delta t G(p')$$

$$p^{n+1/2} = p^{n-1/2} + p'$$

### 5. 迭代收敛检查

检查动量方程和连续性方程的残差是否满足收敛准则。若未收敛，返回步骤 2 继续迭代；若收敛，则完成当前时间步计算。

### 6. 时间步推进

将收敛解作为下一时间步的初始条件：

$$u_i^n = u_i^{n+1},\quad p^{n-1/2} = p^{n+1/2}$$

进入下一时间步计算。

### IFSM 算法特点

- **半隐式时间离散**：对流项采用显式 Adams-Bashforth 格式，粘性项采用隐式 Crank-Nicolson 格式，兼顾计算效率与数值稳定性
- **压力-速度迭代耦合**：通过迭代求解确保每个时间步内动量方程和连续性方程的同时满足
- **二阶时间精度**：采用中间时间层 $(n+1/2)$ 的压力存储，保证时间方向的二阶精度
- **分裂步框架**：保持了经典分裂步法的投影特性，将速度场投影到散度为零的空间
- **适用于复杂流动**：特别适合需要高时间精度的瞬态流动模拟，如湍流直接数值模拟
- **数值稳定性**：隐式处理刚性项，允许使用较大的时间步长
- **误差可控**：通过迭代过程控制分裂误差，确保解的物理合理性

## SIMPLE 与 IFSM 算法对比

SIMPLE 和 IFSM 都是求解不可压缩 Navier-Stokes 方程的压力-速度耦合算法，同属于"预测-修正"类的投影法框架。然而，它们在设计哲学、离散策略和主要应用场景上存在显著差异。

### 核心特性对比

| 对比维度     | SIMPLE 算法                                                       | IFSM 算法                                                                     |
| :----------- | :---------------------------------------------------------------- | :---------------------------------------------------------------------------- |
| **核心思想** | 半隐式压力耦合方程法，侧重于在迭代层面解决压力-速度耦合问题       | 迭代分裂步法，侧重于在时间推进层面通过迭代减少算子分裂误差                    |
| **主要应用** | 稳态流动（首选），通过伪瞬态推进或直接迭代求稳态解                | 瞬态流动（首选），特别适用于时间精度要求高的非定常计算                        |
| **时间离散** | 全隐式（Implicit Euler 或二阶后向差分），稳态计算常忽略时间导数项 | 半隐式，对流项显式，粘性项和压力项隐式                                        |
| **压力存储** | 压力存储于整时间步 $n, n+1$                                       | 压力存储于半时间步 $n-1/2, n+1/2$，支持二阶时间精度                           |
| **预测步**   | 使用上一迭代步压力 $p^{m-1}$，包含对流和扩散项的对角线系数 $A_D$  | 使用前一时间步压力 $p^{n-1/2}$，粘性项采用 Crank-Nicolson 格式                |
| **修正步**   | 压力修正源项为 $D(\rho u_i^*)$，速度修正与 $A_D^{-1}$ 相关        | 压力修正源项为 $\frac{D(\rho v)^*}{\Delta t}$，速度修正与 $\Delta t$ 直接相关 |
| **非对角项** | 忽略邻居速度修正影响，需要压力松弛                                | 不涉及此问题，动量方程形式不同                                                |
| **松弛需求** | 必须使用压力松弛 $\alpha_p$（0.1-0.3）保证稳定性                  | 通常不需要特殊压力松弛                                                        |
| **计算特性** | 稳态计算中快速收敛，时间精度一阶或二阶                            | 高时间精度（二阶）设计，允许较大稳定时间步长                                  |
| **设计目标** | 通用稳健的稳态流求解器                                            | 时间精确的瞬态流求解器                                                        |

### 算法关系分析

两者根本区别体现在压力修正方程的源项：

- **SIMPLE 等效源项**：$\frac{A_P}{\rho} D(\rho u_i^*)$
- **IFSM 源项**：$\frac{1}{\Delta t} D(\rho u_i^*)$

其中 SIMPLE 的对角线系数包含完整贡献：
$$A_P = \frac{\rho}{\Delta t} + \text{对流与扩散贡献}$$

**关键结论**：

当 $\Delta t \to \infty$（稳态），IFSM 源项趋于零而失效，SIMPLE 因保留空间离散贡献仍可工作。

当 $\Delta t \to 0$（瞬态），$A_P \approx \frac{\rho}{\Delta t}$，两算法行为高度相似。

因此，SIMPLE 可视为 IFSM 的推广，通过保留空间离散算子的影响，将有效性从瞬态扩展到稳态领域，而 IFSM 专注于瞬态计算的高精度和稳定性。

## 时间步与迭代步的关系

时间步和迭代步的关系是**多层次、嵌套且因问题类型而异**的。以下是关于这一关系的核心论述整理。

### 基本关系：外层与内层

在求解过程中，尤其是在处理**非线性和变量耦合**时，会形成一个**嵌套的循环结构**：

- **时间步循环**：最外层的循环，用于推进物理时间（瞬态问题）或作为一种收敛手段（稳态问题）
- **外层迭代**：在每个时间步内部，用于更新**非线性和变量耦合**（如速度-压力耦合、湍流模型等）的循环
- **内层迭代**：在外层迭代的每一步中，用于求解**单个线性方程组**（如一个动量方程或压力修正方程）的循环

> **文件原文（第 212 页）**：
> "The iterations within one time step, in which the non-linear and coupling terms are updated, are called _outer iterations_ to distinguish them from the _inner iterations_ performed on linear systems with fixed coefficients."
> 在一个时间步内，更新非线性和耦合项的迭代被称为 _外层迭代_，以区别于在系数固定的线性系统上执行的 _内层迭代_。

### 瞬态问题（时间精确模拟）

对于瞬态问题，目标是获得精确的时间演化历程。

- **时间步长 $\Delta t$**：根据**精度要求**选择，需要足够小以捕捉流动的物理变化
- **外层迭代**：在每个时间步内，必须进行多次外层迭代，直到该时间步下的**整个非线性方程组系统**满足一个较窄的容差

**目的**：确保在进入下一个时间步之前，当前时间步 $t_{n+1}$ 的解完全满足离散化的 Navier-Stokes 方程。

> **文件原文（第 212 页）**：
> "If we are computing an unsteady flow and time accuracy is required, iteration must be continued within each time step until the entire system of non-linear equations is satisfied to within a narrow tolerance."

### 稳态问题（寻求稳态解）

对于稳态问题，最终的解与时间历史无关，时间推进只是一种达到稳态的计算策略。

- **时间步长 $\Delta t$**：可以视为一种**收敛加速参数或松弛因子**。通常使用**大时间步长**或**无限时间步长**（即忽略时间导数项）来快速逼近稳态解
- **外层迭代**：
  - **方法一（无限时间步）**：完全去掉非稳态项，直接迭代求解稳态非线性方程。此时没有时间步的概念，只有外层迭代
  - **方法二（时间推进法）**：保留非稳态项，但每个时间步**只进行一次外层迭代**。这种方法对收敛容差的要求可以宽松很多

> **文件原文（第 212 页）**：
> "For steady flows, the tolerance can be much more generous; one can then either take an infinite time step and iterate until the steady non-linear equations are satisfied, or march in time without requiring full satisfaction of the non-linear equations at each time step (in that case, one usually performs only one iteration per time step)."

### 时间步长与松弛因子的等价性

在求解稳态问题时，**时间步长 $\Delta t$** 和**速度的松弛因子 $\alpha_u$** 在代数方程中的作用是等价的。两者都会对离散方程的对角线系数 $A_P$ 做出贡献。

> **文件原文（第 218-219 页）**：
> "There is a strong similarity between the algebraic equations resulting from the use of under-relaxation when solving steady problems and those resulting from applying the implicit Euler scheme to unsteady equations."

两者的等价关系式：

$$\Delta t = \frac{\rho \alpha_u}{- (1 - \alpha_u) \sum A_k}$$

或

$$\alpha_u = \frac{ - \Delta t \sum A_k }{ - \Delta t \sum A_k + \rho }$$

**关键区别**：

- 使用固定的 $\Delta t$ 进行时间推进，等价于在每个网格点上使用了**不同的、变化的** $\alpha_u$
- 使用固定的 $\alpha_u$ 进行松弛迭代，等价于在每个网格点上使用了**不同的、变化的** $\Delta t$

### 总结

这一章将时间步和迭代步的关系描绘成一个灵活的计算框架：

| 问题类型     | 时间步 $\Delta t$ 的角色       | 外层迭代的作用                                                   | 典型策略                                     |
| :----------- | :----------------------------- | :--------------------------------------------------------------- | :------------------------------------------- |
| **瞬态问题** | **物理时间增量**，由精度决定   | 在**每个时间步内**进行多次迭代，以精确满足该时刻的方程           | 小 $\Delta t$ + 多次外层迭代                 |
| **稳态问题** | **数值松弛因子**，用于加速收敛 | 可以**没有时间步**（纯迭代），或**每个时间步一次迭代**以逼近稳态 | 大 $\Delta t$（或无限） + 一次或多次外层迭代 |

这个框架允许根据具体问题的需求（是追求时间精确性，还是快速获得稳态解）来灵活地配置计算流程。
